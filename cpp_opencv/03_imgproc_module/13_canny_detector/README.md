# canny边缘检测
使用opencv提供的函数`cv::Canny`来进行canny边缘检测。

## 理论
canny边缘检测器在1986年由john f.canny提出，也被很多人认为是最佳的检测器，canny检测器主要致力于满足三个标准
1. 低错误率：即只有边缘才能被检测
2. 定位准确，即检测的边缘位置准确
3. 最小响应：没有边缘只会引起一个检测器响应

## 步骤
1. **滤掉噪声**，通常使用高斯平滑滤波器
2. 找到图像像素强度的**梯度**，可以使用sobel算子
3. 应用**非极大值抑制**，将会去掉一些不被认为是边缘的一部分的像素，剩下的边缘回事一条条很细的线。
4. 应用**迟滞**，这一步将会有两个上下两个阈值
    - 如果一个像素梯度大于上阈值，则这个像素被认为是边缘
    - 如果一个像素梯度小于下阈值，则这个像素被放弃
    - 如果一个像素梯度在上下阈值之间，则只有当这个像素与一个大于上阈值的像素连在一起时才会认为它是边缘
    - 通常canny推荐上下阈值比例在`2:1`与`3:1`之间
5. 更多细节可以查阅图像处理的书籍。

## 程序分析
1. 通过滑动条让用户输入较低的阈值
2. 应用canny检测器并生成一个新的mat，（黑色背景上，浅色代表边缘）
3. 显示

## opencv提供的函数函数`cv::Canny`
```cpp
void cv::Canny	(	InputArray 	image,
					OutputArray 	edges,
					double 	threshold1,
					double 	threshold2,
					int 	apertureSize = 3,
					bool 	L2gradient = false 
)	
```
---

并且在这个程序中使用了函数`copyTo()`的重载功能：
```cpp
void cv::Mat::copyTo	(	OutputArray 	m,
							InputArray 	mask 
)		const
```
---
这个函数原本只有一个参数，代表的是深拷贝的意思，两个参数代表只拷贝第二个参数矩阵中不为0的位置处`*this`的值
- m：	目标矩阵，如果尺寸、元素类型不匹配，会重新进行分配
- mask：	与`*this`具有相同尺寸的操作矩阵，它的非零元素表明这个元素需要被拷贝。这个矩阵必须是` CV_8U`的，可以有一个或多个通道。

